---
title: Fantasy Football Player Rankings
author: ~
date: '2018-08-13'
slug: fantasy-football-player-rankings
categories: []
tags: []
---

```{r, echo = FALSE, warning = FALSE, message = FALSE }
library(readr)
library(dplyr)
library(ggplot2)
library(tidyr)
library(StatRank)
library(stringr)
library(caret)
library(ebbr)
library(rvest)
library(mice)

```

Accurate prediction of player performance is of immense value to those of use who play fantasy football. With this in mind, I was curious about how well simple prediction models could perform in this context. Conveniently, Sean J. Taylor provided some nice code to make [2017 fantasy football projections](https://gist.github.com/seanjtaylor/b4d423dad0083cc8cc5b2a9fd1e4e63e) which we can use to make 2018 predictions. Looking at his predictions for 2017, I'm not overly optimistic about how the models will perform. At any rate, it ought to be fun to see what theys produce.

My code is mostly identical to Sean's except I've updated some of the year values so that it predicts for the 2018 season and makes use of armchair analysis data from 2017. Since I only changed a few values in the original code to create the analysis datasets, I've decided not to display it. However, while running the block of Sean's code to generate the actual predictions, I encountered some errors having to do with his use of the return() function. Because of this, I'm going to display the code I used to generate the 2018 predictions.

```{r, echo = FALSE, warning = FALSE, message = FALSE, cache = TRUE}

## One row per player, with combine, draft position, and name.
player <- read_csv('C:\\Users\\rtravis\\Documents\\NFL\\nfl_00-17\\PLAYER.csv')

## One row per (player, game) with all stats for that game.
offense <- read_csv('C:\\Users\\rtravis\\Documents\\NFL\\nfl_00-17\\OFFENSE.csv')

## One row per game
game <- read_csv('C:\\Users\\rtravis\\Documents\\NFL\\nfl_00-17\\GAME.csv')


off.games <- offense %>%
	inner_join(player %>% select(player, pos1)) %>%
	filter(pos1 %in% c('WR', 'TE', 'RB', 'QB')) %>%
	## add the week/seas of the game
	dplyr::select(-seas) %>%
	inner_join(game %>% select(gid, wk, seas))


all.games <- off.games %>%
	group_by(player, seas) %>%
	do({
		data_frame(wk = 1L:17L)
	})

off.games2 <- all.games %>%
	left_join(off.games) %>%
	dplyr::select(player, seas, wk, pa, py, tdp, ints, ra, ry, tdr, trg, rec, recy, tdrec, fuml) %>%
	mutate(gms = as.integer(!is.na(trg)))

seasons <- off.games2 %>%
	filter(gms > 0, tdr < ra + 1) %>%
	gather(metric, value, pa:gms) %>%
	mutate(value = coalesce(value, 0L)) %>%
	group_by(player, seas, metric) %>%
	summarise(value = sum(value)) %>%
	ungroup()


seasons.with.rates <- seasons %>%
	## add the rate stats
	spread(metric, value) %>%
	inner_join(player %>% dplyr::select(player, pos1)) %>%
	group_by(seas, pos1) %>%
	do({
		## fumbles lost per (ra + trg + pa)
		x4 <- add_ebb_estimate(., pmin(fuml, ra + trg + pa), pmax((ra + trg + pa), 1))
		if (first(.$pos1) == 'QB') {
			x1 <- data_frame(.fitted = rep(0, nrow(.)))
			x2 <- data_frame(.fitted = rep(0, nrow(.)))
			x5 <- add_ebb_estimate(., pmax(ints, 0), pmax(pa, 1))
			x6 <- add_ebb_estimate(., pmax(tdp, 0), pmax(pa, 1))
		} else {
			x1 <- add_ebb_estimate(., rec, pmax(trg, 1))
			x2 <- add_ebb_estimate(., tdrec, pmax(trg, 1))
			x5 <- data_frame(.fitted = rep(0, nrow(.)))
			x6 <- data_frame(.fitted = rep(0, nrow(.)))
		}
		if (first(.$pos1) %in% c('RB', 'QB')) {
			x3 <- add_ebb_estimate(., tdr, pmax(ra, 1))
		} else {
			x3 <- data_frame(.fitted = rep(0, nrow(.)))
		}
		ypc <- with(., sum(ry) / sum(ra))
		ypt <- with(., sum(recy) / sum(trg))
		ypp <- with(., sum(py) / sum(pa))
		new.cols <- data_frame(rec_trg = x1$.fitted,
													 tdrec_trg = x2$.fitted,
													 tdr_ra = x3$.fitted,
													 fuml_ratrg = x4$.fitted,
													 ry_ra = (.$ry + ypc) / (.$ra + 1),
													 recy_trg = (.$recy + ypt) / (.$trg + 1),
													 ints_pa = x5$.fitted,
													 tdp_pa = x6$.fitted,
													 py_pa = (.$py + ypp) / (.$pa+1))
		bind_cols(., new.cols)
	}) %>%
	ungroup() %>%
	dplyr::select(-pos1) %>%
	gather(metric, value, -player, -seas)


all.metrics <- with(seasons.with.rates, unique(metric))
season.2018 <- seasons.with.rates %>%
	filter(seas == 2017, metric == 'gms', value >= 1) %>%
	dplyr::select(player) %>%
	mutate(seas = 2018) %>%
	group_by(player, seas) %>% do({
		data_frame(metric = all.metrics, value = NA)
	})


header <- c('player', 'pos', 'college', 'stats', 'height', 'weight', 'forty', 'vertical', 'bench', 'broad', 'threecone', 'shuttle', 'drafted')

url.extract <- function(tds) {
	results <- c()
	for(td in tds) {
		children <- html_children(td)
		if (length(children) == 0) {
			results <- c(results, NA)
		} else{
			results <- c(results, (html_attr(html_children(td), 'href')))
		}
	}
	results
}

combine.table <- data_frame(year = 2018) %>%
	group_by(year) %>% do({
		url <- paste('http://www.pro-football-reference.com/draft/', .$year, '-combine.htm', sep ='')
		html.table <- read_html(url) %>%
			html_nodes('table') %>%
			first
		urls <- html.table %>%
			html_nodes('tr td:nth-child(4)') %>%
			url.extract
		my.table <- html_table(html.table)
		colnames(my.table) <- header
		my.table <- my.table %>%
			filter(pos != 'Pos') %>%
			mutate(url = urls)
		my.table
	})

draft.header <- c('round', 'pick', 'team', 'player', 'pos', 'age', 'to', 'ap1', 'pb', 'st', 'carav', 'drav', 'games', 'pass.cmp', 'pass.att', 'pass.yds', 'pass.tds', 'pass.ints', 'rush.att', 'rush.yds', 'rush.tds', 'receptions', 'rec.yds', 'rec.tds', 'tackles', 'ints', 'sacks', 'college', 'stats')
draft.table <- data_frame(year = 2018) %>%
	group_by(year) %>% do({
		url <- paste('http://www.pro-football-reference.com/years/', .$year, '/draft.htm', sep ='')
		doc <- read_html(url)
		html.table <- doc %>%
			html_nodes('table') %>%
			first
		urls <- html.table %>%
			html_nodes('tr td:nth-child(29)') %>%
			url.extract
		my.table <- html_table(html.table)
		colnames(my.table) <- draft.header
		my.table <- my.table %>%
			filter(pos != 'Pos') %>%
			mutate(url = urls)
		my.table
	}) %>%
	ungroup()

draft.table2 <- draft.table %>%
	select(player, dpos = pick, pos, age)
combine.table2 <- combine.table %>%
	full_join(draft.table2) %>%
	filter(pos %in% c('QB', 'RB', 'WR', 'TE'))

rookies.with.stats <- combine.table2 %>%
	dplyr::select(year, player, pos1 = pos, height, weight, forty, vertical, bench, threecone, shuttle, broad, dpos) %>%
	mutate(height = ifelse(is.na(height), 'NA-NA', height)) %>%
	separate(height, c('feet', 'inches'), sep = '-', convert = TRUE) %>%
	mutate(height = feet * 12 + inches) %>%
	select(-feet, -inches) %>%
	gather(metric, value, height, weight, forty, vertical, bench, threecone, shuttle, broad, dpos) %>%
	filter(!is.na(value), value != '') %>%
	mutate(value = as.numeric(value)) %>%
	spread(metric, value) %>%
	mutate(start = 2018) %>%
	ungroup()

rookies.2018 <- rookies.with.stats %>%
	dplyr::select(player) %>%
	mutate(seas = 2018) %>%
	group_by(player, seas) %>% do({
		data_frame(metric = all.metrics, value = NA)
	})

season.metrics <- seasons.with.rates %>%
	bind_rows(season.2018) %>%
	bind_rows(rookies.2018) %>%
	group_by(player, metric) %>%
	arrange(seas) %>%
	mutate(career.year = 1:n(),
				 lst = coalesce(lag(value), 0),
				 avg = coalesce(lag(cumsum(value) / cumsum(rep(1, length(value)))), 0)) %>%
	ungroup()


player.metrics <-
	bind_rows(player %>% select(player, height, weight, forty, bench, broad, shuttle, vertical, dpos, start, pos1),
						rookies.with.stats %>% dplyr::select(-year, -threecone) %>% ungroup()) %>%
	gather(metric, value, -player, -pos1) %>%
	mutate(value = ifelse(value == 0.0, NA, value)) %>%
	spread(metric, value) %>%
	mutate(undrafted = ifelse(is.na(dpos), 1, 0))

to.impute <- player.metrics %>% 
	dplyr::select(-player, -pos1)
imputed <- mice(to.impute, print = FALSE)


player.metrics2 <- bind_cols(player.metrics %>% dplyr::select(player, pos1), 
																						 complete(imputed))


features <- season.metrics %>%
	select(player, seas, metric, lst, avg) %>%
	gather(which.lag, lag.value, lst, avg) %>%
	unite(metric, metric, which.lag) %>%
	spread(metric, lag.value) %>%
	inner_join(player.metrics2) %>%
	mutate(career.seas = seas - start) %>%
	dplyr::select(-start)


```

###Predictions

The code to generate the predictions is a little tricky, since it uses dplyr's non standard evaluation (it's generates them within the do() function). You'll notice within the if else block of code I've removed the return function. The code builds separate models for rushing attempts, passing attempts, receiving yards, etc. for a total of 12 models. The first three metrics, rushing attempts, receiving targets, and passing attempts are the "opportunity" metrics and are modeled using a k-nearest neighbors algorithm. The justification for this that Sean provides is that penalized linear models used for other 9 rate metics would "shrink" the predictions too much (push them toward the average). The ultimate projections for player performance are heavily influenced by the opportunity projections, so it's very important to get them right.

```{r, message = FALSE, warning = FALSE, cache = TRUE}
mySummary <- function(data, lev = NULL, model = NULL) {
	out <- c(mean(abs(data$obs - data$pred)), 
					 Evaluation.NDCG(order(data$pred), data$obs))
	names(out) <- c('MAE', 'NDCG')
	out
}
ctrl <- trainControl(method = 'cv',
										 number = 10,
										 summaryFunction = mySummary)

config <- data_frame(metric = c('ra', 'trg', 'pa', 'rec_trg', 'ry_ra', 'tdr_ra', 'tdrec_trg', 'recy_trg', 'py_pa', 'tdp_pa', 'ints_pa', 'fuml_ratrg'),
										 method = c('kknn', 'kknn', 'kknn', rep('glmnet', 9)),
										 outcome.metric = c('NDCG', 'NDCG', 'NDCG', rep('RMSE', 9)),
										 maximize = c(TRUE, TRUE, TRUE, rep(FALSE, 9)),
										 key = 1)


positions <- data_frame(pos1 = c('WR', 'TE', 'RB', 'QB'), key = 1)
cutoffs <- data_frame(cutoff = 2016:2017, key = 1)


preds <- config %>%
	inner_join(positions) %>%
	inner_join(cutoffs) %>%
	group_by(metric, pos1, cutoff) %>% do({
		my.metric <- first(.$metric)
		my.pos <- first(.$pos1)
		my.cutoff <- first(.$cutoff)
		for.reg <- season.metrics %>%
			filter(metric == my.metric) %>%
			dplyr::select(player, seas, value) %>%
			inner_join(features, by = c('player', 'seas')) %>%
			filter(pos1 == my.pos) %>%
			ungroup()
		if (str_detect(my.metric, 'pa') & my.pos != 'QB') {
			for.reg$yhat <- 0
			for.reg %>% select(player, seas, yhat = yhat)
		} else if (str_detect(my.metric, 'trg') & my.pos == 'QB') {
			for.reg$yhat <- 0
			for.reg %>% select(player, seas, yhat = yhat)
		} else if (str_detect(my.metric, 'ra') & my.pos %in% c('TE', 'WR')) {
			for.reg$yhat <- 0
			for.reg %>% select(player, seas, yhat = yhat)
		} else {
		X <- model.matrix( ~ 0 + ., for.reg %>% dplyr::select(-player, -value, -pos1))
		nzv <- nearZeroVar(X)
		X <- X[, -nzv]
		y <- with(for.reg, value)
		trainable <- !is.na(y) & (for.reg$seas <= my.cutoff)
		fit <- train(X[trainable,],y[trainable],
								 metric = first(.$outcome.metric),
								 method = first(.$method),
								 maximize = first(.$maximize),
								 trControl = ctrl,
								 preProcess = c("center", "scale"))
		for.reg$yhat <- predict(fit, X)
		for.reg %>% dplyr::select(player, seas, yhat = yhat)
		}
	})

```


###Rankings based on Predictions

```{r rnks, cache = TRUE}

rnks <- preds %>%
	spread(metric, yhat) %>%
	mutate(py = pa * py_pa,
				 tdp = pa * tdp_pa,
				 ints = pa * ints_pa,
				 rec = trg * rec_trg,
				 recy = trg * recy_trg,
				 ry = ra * ry_ra,
				 td = trg * tdrec_trg+ ra * tdr_ra,
				 fuml = fuml_ratrg * (ra + pa + trg),
				 fpts = py / 25 
				 + recy / 15 
				 + ry / 10 
				 + rec * 0.5 
				 + (td + tdp) * 6 
				 + ints * -2 
				 + fuml * -2) %>%
	left_join(player %>% select(player, pos1, fname, lname)) %>%
	dplyr::select(seas, player, fname, lname, pos1, fpts) %>%
	group_by(cutoff, seas, pos1) %>%
	arrange(-fpts) %>%
	mutate(rnk = row_number())

```

####Running Back Rankings
```{r}
rnks %>% filter(pos1 == 'RB', seas == 2018, cutoff == 2017) %>% print(n = 30)

```

####Wide Receiver Rankings
```{r}
rnks %>% filter(pos1 == 'WR', seas == 2018, cutoff == 2017) %>% print(n = 30)

```

####Quarterback Rankings
```{r}
rnks %>% filter(pos1 == 'QB', seas == 2018, cutoff == 2017) %>% print(n = 30)

```

####Tight End Rankings
```{r}
rnks %>% filter(pos1 == 'TE', seas == 2018, cutoff == 2017) %>% print(n = 30)

```

###Model Performance Plots

```{r}
truth <- season.metrics %>%
	filter(seas == 2017) %>%
	dplyr::select(-career.year, -lst, -avg) %>%
	spread(metric, value) %>%
	mutate(fpts = py / 25 
				 + recy / 15 
				 + ry / 10 
				 + rec * 0.5 
				 + (tdr + tdrec + tdp) * 6 
				 + ints * -2 
				 + fuml * -2) %>%
	arrange(-fpts) %>%
	mutate(rnk = row_number())

rnks %>%
	filter(cutoff == 2016, seas == 2017) %>%
	inner_join(truth %>% dplyr::select(player, seas, fpts.true = fpts)) %>%
	ggplot(aes(x = fpts, y = fpts.true)) + 
	geom_point() +
	facet_wrap('pos1', scales = 'free') +
	theme_bw() +
	geom_abline() +
	xlab('Projected Points') +
	ylab('Actual Points')
```


###Comments
These predictions do not seem very good at all to me. Looking at the last plot you can see the immense variability about the 45 degree line, some of the estimates are off by very large amounts. This is maybe not surprising when you consider the very limited basis on which the "opportunity" (rushing attempts, etc) projections are made. There is a lot of information that is not captured by previous data. Allowing for smooth functions of the predictors in the rate models would probably improve the performance as well.

Ultimately, in my opinion a better approach to fantasy football player projection is something like what is done at [Fantasy Football Analytics](https://fantasyfootballanalytics.net/2018/07/2018-fantasy-football-projections.html). The approach they take is to combine the projections of lots of analysts via some weighting scheme. This would allow the incorporation of a lot more information than the models above, as well as averaging over particular analyst biases.  

